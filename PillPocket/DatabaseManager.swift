import Foundation
import SQLite








struct Reminder: Identifiable {
    let id: Int64
    var category: String
    var times_R: Int
    var reminderTime: Date
    var lastUpdated: Date
    var created: Date
    var deleted: Bool
}
struct MedicationReminder: Identifiable {
    var id: Int64?  // Optional because it's autogenerated by the database
    var medication: String
    var reminderTime: Date

    // Initialize without ID for new reminders
    init(medication: String, reminderTime: Date) {
        self.medication = medication
        self.reminderTime = reminderTime
    }

    // Initialize with ID for reminders fetched from the database
    init(id: Int64, medication: String, reminderTime: Date) {
        self.id = id
        self.medication = medication
        self.reminderTime = reminderTime
    }
}

extension DateFormatter {
    static let iso8601Full: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.timeZone = TimeZone(secondsFromGMT: -6 * 3600) // Adjust timezone as needed
        formatter.locale = Locale(identifier: "en_US_POSIX")
        return formatter
    }()
}

class DatabaseManager: ObservableObject {
    
    
    
    @Published var reminders: [Reminder] = []
    
    func checkAndUpdateRemindersHome() {
            // Format the current date as a string in 'yyyy-MM-dd' format.
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyy-MM-dd"
            dateFormatter.timeZone = TimeZone.current
            let currentDate = dateFormatter.string(from: Date())
            
            // Prepare the SQL query to select reminders that need to be marked as deleted.
            let sql = "UPDATE RemindersHome SET r_B_deleted = 1 WHERE r_B_takentoggle = 1 OR date(r_D_datetobetaken) < date(?)"
            
            do {
                // Assuming `db` is your SQLite connection.
                let statement = try db!.prepare(sql)
                try statement.run(currentDate)
                // print("Records marked for deletion if necessary.")
                
                // Optionally, after updating the database, refresh your reminders list if it's being displayed in the UI.
                // This could involve re-fetching from the database or adjusting your reminders array.
                // refreshReminders() // A hypothetical function that fetches reminders and updates the @Published reminders array.
            } catch {
                // print("Error updating RemindersHome records: \(error)")
            }
        }
        
    
    
    func fetchCountForMedicine(medicineName: String) throws -> Int {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let query = remindersHome.filter(r_S_medicine == medicineName && r_B_deleted == false)
        let count = try db.scalar(query.count) // This counts the rows matching the query
       
        return count
    }

    
    
    
    
    
    
    
    
    static let shared = DatabaseManager() // Singleton instance
    private let schedule = Table("Schedule")
    private var db: Connection? // Changed to 'var' to allow reassignment
    // Timings_Schedule Table
    // Define the new Timings_Schedule table
      private let timingsSchedule = Table("Timings_Schedule")
      private let timingId = Expression<Int64>("id") // Autoincrement primary key
      private let timingMedication = Expression<String>("MedicineName")
      private let timing = Expression<String>("Timings") // Stores time
      private let dateValue = Expression<Date>("DateValue") // Stores date
      private let timingLastUpdated = Expression<Date>("LastUpdated") // Automatically stores update date
      private let timingDeleted = Expression<Bool>("Deleted") // Boolean for logical deletion
  //remindersHome
    private let remindersHome = Table("RemindersHome")
       private let r_I_ID = Expression<Int64>("R_I_ID") // Auto-increment ID
       private let r_S_medicine = Expression<String>("R_S_medicine")
       private let r_B_takentoggle = Expression<Bool>("R_B_takentoggle")
       private let r_I_frequency = Expression<String>("R_I_frequency")
       private let r_I_takendays = Expression<Int>("R_I_takendays")
       private let r_D_startdate = Expression<String>("R_D_startdate")
    private let r_I_times = Expression<Int>("R_I_times")
       private let r_I_originalqty = Expression<Int>("R_I_originalqty")
       private let r_I_updatedqty = Expression<Int>("R_I_updatedqty")
       private let r_T_rem1 = Expression<String>("R_T_rem1")
       private let r_T_rem2 = Expression<String>("R_T_rem2")
       private let r_T_rem3 = Expression<String>("R_T_rem3")
       private let r_T_rem4 = Expression<String>("R_T_rem4")
       private let r_S_wday1 = Expression<String>("R_S_wday1")
       private let r_S_wday2 = Expression<String>("R_S_wday2")
       private let r_S_wday3 = Expression<String>("R_S_wday3")
       private let r_S_wday4 = Expression<String>("R_S_wday4")
       private let r_S_wday5 = Expression<String>("R_S_wday5")
       private let r_S_wday6 = Expression<String>("R_S_wday6")
       private let r_S_wday7 = Expression<String>("R_S_wday7")
       private let r_S_monthdays = Expression<String>("R_S_monthdays")
       private let r_B_deleted = Expression<Bool>("R_B_deleted")
    private let r_D_datetobetaken = Expression<String>("R_D_datetobetaken")
    private let r_B_master = Expression<Int64>("r_B_master")
    private let r_I_dosageIter = Expression<String>("R_I_dosageIter")
    private let r_D_enddate = Expression<String>("R_D_enddate")
    private let r_B_takencount = Expression<Int>("R_B_takencount")
    
    
 
    private let r_D_created = Expression<String>("R_D_created")
    private let r_D_updated = Expression<String>("R_D_updated")


    
    private let remindersTable = Table("reminders")
        private let rem_id = Expression<Int64>("id")
        private let rem_medication = Expression<String>("medication")
        private let rem_reminder = Expression<Date>("reminder")
    
    
    
    // Define the Reminders_Schedule table
    private let remindersSchedule = Table("Reminders_Schedule")
    private let reminderId = Expression<Int64>("id") // Auto-increment primary key
    private let category = Expression<String>("Category")
    private let times_R = Expression<Int>("Times")
    private let reminder = Expression<Date>("Reminder") // Stores time
    private let reminderLastUpdated = Expression<Date>("LastUpdated") // Automatically stores update date
    private let reminderCreated = Expression<Date>("Created") // Stores creation date
    private let reminderDeleted = Expression<Bool>("Deleted") // Boolean for logical deletion

    
    
    // Schedule table

    private let id = Expression<Int64>("id")  // Primary key
    private let medication = Expression<String>("Medication")
    private let timings = Expression<String>("Timings")// This column stores the number of days value used by reminders
    private let taken = Expression<Bool>("Taken")
    private let frequency=Expression<String>("Frequency")
    private let times = Expression<Int>("Times")  // New integer column
    private let quantity = Expression<Int>("Quantity")  // New integer column
    //let now = ISO8601DateFormatter().string(from: Date())
    
   

    // Use 'dateFormatter' for other date formatting and parsing tasks

    
    
    //let now = dateFormatter.string(from: Date()) // Convert current date to string

    
    
    private let refill = Expression<Bool>("Refill")
    private let deleted = Expression<Bool>("Deleted")
    private let lastUpdated = Expression<String>("LastUpdated")  // New column for last updated timestamp
    private let created = Expression<String>("Created")  // New column for created timestamp
    private let rem1 = Expression<String>("Rem1")
    private let rem2 = Expression<String>("Rem2")
    private let rem3 = Expression<String>("Rem3")
    private let rem4 = Expression<String>("Rem4")
    
    private let wday1 = Expression<String>("wday1")
    private let wday2 = Expression<String>("wday2")
    private let wday3 = Expression<String>("wday3")
    private let wday4 = Expression<String>("wday4")
    private let wday5 = Expression<String>("wday5")
    private let wday6 = Expression<String>("wday6")
    private let wday7 = Expression<String>("wday7")

    private let month_days = Expression<String?>("month_days")
    


    
    
    
    
   // let dateFormatter = ISO8601DateFormatter()
    var dateFormatter: DateFormatter
     let now: String
   



    
    
    
   /*xoxo
    
  let medicines = [
         MedicineRow(medicine: "Medicine 1", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         
         MedicineRow(medicine: "Medicine 13", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"",rem2:"",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 21", frequency: "W", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"",rem2:"",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 31", frequency: "M", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"",rem2:"",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         
         MedicineRow(medicine: "Medicine 12", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 13", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"6:41 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 14", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"6:41 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 15", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"6:41 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 16", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"6:41 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
         MedicineRow(medicine: "Medicine 17", frequency: "D", quantity: 2, refill: true, times: 2,deleted: false,created: Date.now,rem1:"4:55 PM",rem2:"6:41 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:"")
    
        // Add more rows as needed
    ]
   xoxo */
    
    
    let medicines = [

    MedicineRow(medicine: "METFORMIN", frequency: "D", quantity: 10, refill: true, times: 2,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
    MedicineRow(medicine: "ATORVASTATIN", frequency: "D", quantity: 30, refill: true, times: 1,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
    MedicineRow(medicine: "TELAMISARTAN-HYDROCHLOROTHIAZIDE", frequency: "D", quantity: 30, refill: true, times: 1,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
    MedicineRow(medicine: "ACYCLOVIR", frequency: "D", quantity: 20, refill: true, times: 2,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
    MedicineRow(medicine: "DEXAMETHASONE", frequency: "D", quantity: 20, refill: true, times: 1,deleted: false,created: Date.now,rem1:"6:55 PM",rem2:"4:55 PM",rem3:"",rem4:"",wday1:"",wday2:"",wday3:"",wday4:"",wday5:"",wday6:"",wday7:""),
             
    ]
    
    
    
    
    
    
    
    
    
    // Alternative Reminders code dev
   
    
    
    func updateTimeForMedication(medication: String, timeString: String) throws {
           guard let db = self.db else {
               throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
           }

           let medicationToUpdate = schedule.filter(self.medication == medication)
           try db.run(medicationToUpdate.update(rem1 <- timeString))
       }
  
    // Function to drop the remindersHome table if it exists
       private func dropRemindersHomeTableIfExists() throws {
           guard let db = self.db else {
               throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
           }
           try db.run(remindersHome.drop(ifExists: true))
       }
    
    static func createLocalTimezoneDateFormatter() -> DateFormatter {
           let dateFormatter = DateFormatter()
           dateFormatter.timeZone = TimeZone.current // Set to the user's current timezone
           dateFormatter.locale = Locale.current // Set to the user's current locale
           dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss" // ISO8601 format with local timezone
           return dateFormatter
       }
    
    static func convertToDate(dateString: String) -> Date? {
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"
            return dateFormatter.date(from: dateString)
        }
    
 static   func getCurrentFormattedDate() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"
        return dateFormatter.string(from: Date())
    }
    
    
    private func createTableRH() throws {
        try db?.run(remindersHome.create(ifNotExists: true) { t in
            t.column(r_I_ID, primaryKey: .autoincrement)
            t.column(r_S_medicine) // No need for Expression<String>("R_S_medicine")
            t.column(r_B_takentoggle)
            t.column(r_I_frequency)
            t.column(r_I_times)
            t.column(r_I_takendays)
            t.column(r_D_startdate)
            t.column(r_I_originalqty)
            t.column(r_I_updatedqty)
            t.column(r_T_rem1)
            t.column(r_T_rem2)
            t.column(r_T_rem3)
            t.column(r_T_rem4)
            t.column(r_S_wday1)
            t.column(r_S_wday2)
            t.column(r_S_wday3)
            t.column(r_S_wday4)
            t.column(r_S_wday5)
            t.column(r_S_wday6)
            t.column(r_S_wday7)
            t.column(r_S_monthdays)
            t.column(r_B_deleted,defaultValue: false)
            t.column(r_D_datetobetaken,defaultValue: "0")
            t.column(r_B_master,defaultValue: 0)
            t.column(r_I_dosageIter,defaultValue: "0")
            t.column(r_D_enddate,defaultValue: "0")
            t.column(r_D_created,defaultValue:now)
            t.column(r_D_updated,defaultValue: "0")
            
            
          
            // Ensure the correct data types are used for each column
        })
    }

    
    
    

    
    
    func fetchReminderTimesForMedication(medicationName: String) throws -> [String: String] {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let query = schedule.filter(medication == medicationName)
        if let scheduleRow = try db.pluck(query) {
            return [
                "rem1": scheduleRow[rem1],
                "rem2": scheduleRow[rem2],
                "rem3": scheduleRow[rem3],
                "rem4": scheduleRow[rem4],
                
                
                
                
                
                
                //"rem5": scheduleRow[rem5]
                // Add more if needed
            ]
        } else {
            throw NSError(domain: "DatabaseError", code: 101, userInfo: ["description": "Medication not found"])
        }
    }
    
    
    
    
        func insertMedicationReminder(_ reminder: MedicationReminder) throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }
            
            let insert = remindersTable.insert(
                rem_medication <- reminder.medication,
                rem_reminder <- reminder.reminderTime
            )
            // Execute the insert and let SQLite handle the ID
            try db.run(insert)
        }
    

    func fetchMedicationReminders() throws -> [MedicationReminder] {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        return try db.prepare(remindersTable).map { row in
            MedicationReminder(
                id: row[rem_id],
                medication: row[rem_medication],
                reminderTime: row[rem_reminder]
            )
        }
    }

    func updateReminderTimeForMedication(medicationName: String, newTime: Date, forReminder: String) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let timeFormatter = DateFormatter()
        timeFormatter.timeStyle = .short
        let timeString = timeFormatter.string(from: newTime)

        let medicationToUpdate = schedule.filter(medication == medicationName)
        
        var updateStatement: Update
        
        switch forReminder {
        case "rem1":
            updateStatement = medicationToUpdate.update(rem1 <- timeString)
            
        case "rem2":
            updateStatement = medicationToUpdate.update(rem2 <- timeString)
        case "rem3":
            updateStatement = medicationToUpdate.update(rem3 <- timeString)
        case "rem4":
            updateStatement = medicationToUpdate.update(rem4 <- timeString)
        // Add more cases as needed for rem5, rem6, etc.
        default:
            throw NSError(domain: "UpdateError", code: 101, userInfo: ["description": "Invalid reminder identifier"])
        }

        try db.run(updateStatement)
    }

    
    
    
    
    
    
    
    
    
    
    func deleteMedicationReminder(_ reminder: MedicationReminder) throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        if let id = reminder.id {
            let reminderToDelete = remindersTable.filter(rem_id == id)
            try db.run(reminderToDelete.delete())
        } else {
            // Handle the case where id is nil, if necessary
        }
    }


   
        private func dropMedicationReminderTableIfExists() throws {
            guard let db = db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            try db.run(remindersTable.drop(ifExists: true))
        
    }

    
    // Alternative Reminders code dev
    
    
    private func createmedicationRemindersTable() throws {
            guard let db = db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            try db.run(remindersTable.create(ifNotExists: true) { t in
                t.column(rem_id, primaryKey: .autoincrement)
                t.column(rem_medication)
                t.column(rem_reminder)
            })
        }
    private func recreateScheduleTable() throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        // Drop the existing 'Schedule' table
      //  try db.run(schedule.drop(ifExists: true))
       //ATTN: Remove the above before the final build so that the schema doesn't get dropped everytime apps starts.
       
    }
    
    func updateReminderTime(id: Int64, newTime: Date) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let reminderToUpdate = remindersSchedule.filter(reminderId == id)
        
        // Perform the update
        try db.run(reminderToUpdate.update(reminder <- newTime))

        // Fetch and print the updated row
        if let updatedRow = try db.pluck(reminderToUpdate) {
            let fetchedCategory = updatedRow[category]
            let fetchedTimes = updatedRow[times_R]
            let fetchedReminderTime = updatedRow[reminder]

            // print("Updated Reminder - ID: \(id), Category: \(fetchedCategory), Times: \(fetchedTimes), Reminder Time: \(fetchedReminderTime)")
        } else {
            // print("No row found for reminder ID \(id) after update")
        }
    }

    
    
    
    private func getTodayAtSevenPM() -> Date {
            var calendar = Calendar.current
            calendar.timeZone = .current // Adjust the time zone if necessary
            if let todayAtSevenPM = calendar.date(bySettingHour: 19, minute: 0, second: 0, of: Date()) {
                return todayAtSevenPM
            }
            return Date() // Fallback to current date and time if something goes wrong
        }
    
    func fetchReminders() throws -> [Reminder] {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            return try db.prepare(remindersSchedule).map { row in
                Reminder(
                    id: row[reminderId],
                    category: row[category],
                    times_R: row[times_R],
                    reminderTime: row[reminder],
                    lastUpdated: row[reminderLastUpdated],
                    created: row[reminderCreated],
                    deleted: row[reminderDeleted]
                    
                )
            }
        }

    
    
    func updateMedicineTimings(medication: String, newTimings: String) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicationToUpdate = schedule.filter(self.medication == medication)
        try db.run(medicationToUpdate.update(timings <- newTimings))
    }

    
    
    
    
    
    
    
    
    
    
    
    func fetchMedicinesWithRefills() throws -> [MedicineRow] {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let dateFormatter = ISO8601DateFormatter()

       

        return try db.prepare(schedule.filter(refill == true && deleted == false)).map { row in
            let createdDateString = row[created]
            let createdDate = dateFormatter.date(from: createdDateString) ?? Date() // Fallback to current date if conversion fails


            return MedicineRow(
                id: row[id],
                medicine: row[medication],
                frequency: row[frequency],
                quantity: row[quantity],
                refill: row[refill],
                times: row[times],
                deleted: row[deleted],
                created: createdDate,
                rem1:row[rem1],
                rem2:row[rem2],
                rem3:row[rem3],
                rem4:row[rem4],
               wday1:row[wday1],
                wday2:row[wday2],
                wday3:row[wday3],
                wday4:row[wday4],
                wday5:row[wday5],
                wday6:row[wday6],
                wday7:row[wday7]
                
                
                
                
            )
        }
    }

    
    
    
    func updateTakenStatus(medicationName: String, newStatus: Bool) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        let scheduleItem = schedule.filter(medication == medicationName)
        let now = ISO8601DateFormatter().string(from: Date())


            
            // Fetch and print the row before the update
            if let rowBeforeUpdate = try db.pluck(scheduleItem) {
                // print("Row before update: \(rowBeforeUpdate)")
            } else {
                // print("No row found for medication named \(medicationName) before update")
            }

            // Perform the update
            try db.run(scheduleItem.update(taken <- (newStatus ? true : false),lastUpdated <- now))

            // Fetch and print the row after the update
            if let rowAfterUpdate = try db.pluck(scheduleItem) {
                // print("Row after update: \(rowAfterUpdate)")
            } else {
                // print("No row found for medication named \(medicationName) after update")
            }
        }

    private init() {
        let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first!
        /* do {
         try createTimingsScheduleTable() // Create the Timings_Schedule table
         } catch {
         // print("Unable to create Timings_Schedule table: \(error)")
         }*/
        dateFormatter = DatabaseManager.createLocalTimezoneDateFormatter()
                now = dateFormatter.string(from: Date())

      
        // Drop tables
        do {
            db = try Connection("\(path)/db.sqlite3")
             print("Database Path: \(path)/db.sqlite3")
            //drop table
   //try recreateScheduleTable()
           
            try createTable()
            try createUpdateTrigger()
           
            // drop table
 //try dropRemindersHomeTableIfExists()
            try createTableRH()
            try createMedicineUpdateTrigger()
         //  old try createTriggerForSchedule()
            
            
            
            
            do {
                    // ... your existing setup code ...
                    try createScheduleUpdateTrigger_rem1()
                } catch {
                    // print("Unable to create trigger rem1: \(error)")
                }
            
            // trigger to udpate the date row was changed.
            do {
                    // ... your existing setup code ...
                    try  createRemindersHomeUpdateTrigger()
                } catch {
                    // print("Unable to create trigger rem1: \(error)")
                }
            
           
            
            
            
            
            
            
            do {
                    // ... your existing setup code ...
                  try createScheduleUpdateTrigger_rem2()
                } catch {
                    // print("Unable to create trigger rem2: \(error)")
                }
            
            do {
                    // ... your existing setup code ...
                    try createScheduleUpdateTrigger_rem3()
                } catch {
                    // print("Unable to create trigger rem3: \(error)")
                }
            
            do {
                    // ... your existing setup code ...
                  try createScheduleUpdateTrigger_rem4()
                } catch {
                    // print("Unable to create trigger rem4: \(error)")
                }
            
            
            do {
                    // ... your existing setup code ...
                 try createScheduleUpdateTrigger_wday1()
                // print("trigger created****")
                } catch {
                    // print("Unable to create trigger wday1: \(error)")
                }
        
            
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday3()
                } catch {
                    // print("Unable to create trigger wday3: \(error)")
                }
        
            
            
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday2()
                } catch {
                    // print("Unable to create trigger wday2: \(error)")
                }
      
            
            
            
            
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday4()
                } catch {
                    // print("Unable to create trigger wday4: \(error)")
                }
        
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday5()
                } catch {
                    // print("Unable to create trigger wday5: \(error)")
                }
        
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday6()
                } catch {
                    // print("Unable to create trigger wday6: \(error)")
                }
        
            
            
            do {
                    // ... your existing setup code ...
                try createScheduleUpdateTrigger_wday7()
                } catch {
                    // print("Unable to create trigger wday7: \(error)")
                }
        
            
            // drop initial data
            
          // try insertInitialData()  // Insert initial data after table creation
            
         
            
        } catch {
            db = nil
            // print("Unable to initialize database: \(error)")
        }
        
        do {
                    let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first!
                    db = try Connection("\(path)/db.sqlite3")
                 
            try dropMedicationReminderTableIfExists()
            try createmedicationRemindersTable()
                } catch {
                    // print("Unable to initialize database: \(error)")
                }
    }
// init
    
    func insertReminder(category: String, times_R: Int, reminderTime: Date, created: Date, lastUpdated: Date, isDeleted: Bool = false) throws -> Int64 {
           guard let db = self.db else {
               throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
           }

           let reminderTimeAtSevenPM = getTodayAtSevenPM() // Get today at 7:00 PM
           let insertStatement = remindersSchedule.insert(
               self.category <- category,
               self.times_R <- times_R,
               reminder <- reminderTimeAtSevenPM, // Use the 7:00 PM time
               reminderLastUpdated <- lastUpdated,
               reminderCreated <- created,
               reminderDeleted <- isDeleted
           )

           return try db.run(insertStatement) // Returns the Rowid
       }
    
    
    func printReminder(rowid: Int64) throws {
          guard let db = self.db else {
              throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
          }

          if let reminderRow = try db.pluck(remindersSchedule.filter(reminderId == rowid)) {
              let fetchedCategory = reminderRow[category]
              let fetchedTimes = reminderRow[times_R]
              let fetchedReminderTime = reminderRow[reminder]

              // print("Inserted Reminder - Category: \(fetchedCategory), Times: \(fetchedTimes), Reminder Time: \(fetchedReminderTime)")
          }
      }
  


    
    // Functions to insert data, fetch data, etc.
    
    private func createTable() throws {
        try db?.run(schedule.create(ifNotExists: true) { t in
            t.column(id, primaryKey: .autoincrement) // Auto-incrementing primary key (non-nullable by default)
                    t.column(medication, defaultValue: "empty")
                    t.column(timings, defaultValue: "empty")
                    t.column(taken, defaultValue:false) //
                    t.column(frequency, defaultValue: "empty")
                    t.column(times, defaultValue: 0) //
                    t.column(quantity, defaultValue: 0)
                    t.column(refill, defaultValue: false)
                    t.column(deleted, defaultValue: false) // New boolean column for deletion status

                    t.column(lastUpdated, defaultValue: now)
                     t.column(created, defaultValue: now)
            // Add new columns
                
            t.column(rem1, defaultValue:"")
            t.column(rem2, defaultValue:"")
            t.column(rem3, defaultValue:"")
            t.column(rem4, defaultValue:"")
           // t.column(rem5, defaultValue:"")
          //  t.column(rem6, defaultValue:"")
            t.column(wday1, defaultValue:"")
            t.column(wday2, defaultValue:"")
            t.column(wday3, defaultValue:"")
            t.column(wday4, defaultValue:"")
            t.column(wday5, defaultValue:"")
            t.column(wday6, defaultValue:"")
            t.column(wday7, defaultValue:"")
            t.column(month_days, defaultValue: nil)
            
            
        })
    }//func
    
    
    private func dropRemindersScheduleTableIfExists() throws {
            guard let db = db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            try db.run(remindersSchedule.drop(ifExists: true))
        }
    
    private func createRemindersScheduleTable() throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        try db.run(remindersSchedule.create(ifNotExists: true) { t in
            t.column(reminderId, primaryKey: .autoincrement)
            t.column(category)
            t.column(times_R)
            t.column(reminder)
            t.column(reminderLastUpdated, defaultValue: Date()) // Default to current date
            t.column(reminderCreated, defaultValue: Date()) // Default to current date
            t.column(reminderDeleted, defaultValue: false)
        })
    }

 
    
    
    func updateMedicineRow(_ medicine: MedicineRow) throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        let createdDate=medicine.created
        
        // Assuming 'createdDate' is a Date object
        let dateFormatter = DatabaseManager.createLocalTimezoneDateFormatter()
        let createdDateString = dateFormatter.string(from: createdDate) // Convert Date to String

        
        let medicineToUpdate = schedule.filter(id == medicine.id)
        
        try db.run(medicineToUpdate.update(
            medication <- medicine.medicine,
            frequency <- medicine.frequency,
            quantity <- medicine.quantity,
            created <- createdDateString,//KIDO 2_3:1: edit screen update with date ticker
            times <- medicine.times,
            refill <- medicine.refill
            // Update other fields if necessary
        ))
        
        
        // Check if the update was successful and if so, call `createAndInsertReminderHomeDuplicates()`
           if db.changes > 0 {
               // Assuming `quantity` is the number of times to create duplicates
               try createAndInsertReminderHomeDuplicates(scheduleId: medicine.id, qty: medicine.quantity)
           }
        
        
    }


        
    
    
    
    
    
    
    func deleteMedicineRow(_ medicine: MedicineRow) throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicineToDelete = schedule.filter(id == medicine.id)
        try db.run(medicineToDelete.delete())
    }
    
    
    
    
    
    
    
    
    
    
    
   func insertInitialData() throws {
       //    let now = ISO8601DateFormatter().string(from: Date())
       dateFormatter = DatabaseManager.createLocalTimezoneDateFormatter()
             let  now = dateFormatter.string(from: Date())

        
        
       


           if let count = try db?.scalar(schedule.count), count == 0 {
               var insertStatements = [Insert]()
              
               
               
               

               for medicine in medicines {
                   
                   let insertStatement = schedule.insert(
                       medication <- medicine.medicine,
                       timings <- "12:00 AM", // Default timing
                       rem1 <- "11:10 AM",
                       taken <- false,
                       frequency <- medicine.frequency,
                       quantity <- medicine.quantity,
                       times <- medicine.times,
                       refill <- medicine.refill,
                       deleted <- false,
                       lastUpdated <- now,
                       created <- now

                   )
                   insertStatements.append(insertStatement)
               }

               for insert in insertStatements {
                   try db?.run(insert)
                   // print("Inserted: \(insert)")
               }
               try createAndInsertReminderHomeDuplicates(scheduleId: 1, qty: 2)
               try createAndInsertReminderHomeDuplicates(scheduleId: 2, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 3, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 4, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 5, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 6, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 7, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 8, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 9, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 10, qty: 2)
               try  createAndInsertReminderHomeDuplicates(scheduleId: 11, qty: 2)
               
               
               
           }
        
        
        
        
        
    }
// func
    
    func clearScheduleTable() throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
       // try db.run(schedule.delete())
        let updateAll = schedule.update(deleted <- true)
            try db.run(updateAll)
    }

    
    

    func fetchRemindersHome() throws -> [ReminderHome] {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        
      //  let dateFormatter = DateFormatter()
       // dateFormatter.dateFormat = "yyyy-MM-dd"
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone.current // Use the user's current timezone
        dateFormatter.locale = Locale.current // Use the user's current locale
        // Set the desired date format according to your needs
        dateFormatter.dateFormat = "yyyy-MM-dd"

        
        
        
        let currentDate = dateFormatter.string(from: Date())
        
        
        
        
        // print("Current Date: \(currentDate)")
        // Fetch only reminders with R_D_datetobetaken equal to currentDate
        return try db.prepare(remindersHome.filter(r_D_datetobetaken.like("\(currentDate)%") && r_B_deleted == false)).map { row in
                // Mapping each row to a ReminderHome object
                ReminderHome(
                    r_I_ID: row[r_I_ID],
                    r_S_medicine: row[r_S_medicine],
                    r_B_takentoggle: row[r_B_takentoggle],
                    r_I_times: row[r_I_times],
                    r_I_frequency: row[r_I_frequency],
                    r_I_takendays: row[r_I_takendays],
                    r_D_startdate: row[r_D_startdate],
                    r_I_originalqty: row[r_I_originalqty],
                    r_I_updatedqty: row[r_I_updatedqty],
                    r_T_rem1: row[r_T_rem1],
                    r_T_rem2: row[r_T_rem2],
                    r_T_rem3: row[r_T_rem3],
                    r_T_rem4: row[r_T_rem4],
                    r_S_wday1: row[r_S_wday1],
                    r_S_wday2: row[r_S_wday2],
                    r_S_wday3: row[r_S_wday3],
                    r_S_wday4: row[r_S_wday4],
                    r_S_wday5: row[r_S_wday5],
                    r_S_wday6: row[r_S_wday6],
                    r_S_wday7: row[r_S_wday7],
                    r_S_monthdays: row[r_S_monthdays],
                    r_B_deleted: row[r_B_deleted],
                    r_D_datetobetaken: row[r_D_datetobetaken],
                    r_B_master: row[r_B_master],
                    r_I_dosageIter: row[r_I_dosageIter],
                    r_D_enddate: row[r_D_enddate],
                    r_D_created: row[r_D_created],
                    r_D_updated: row[r_D_updated]
                    )
                    }
                    }
                    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    func fetchSchedule() throws -> [Schedule] {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        
        return try db.prepare(schedule).map { row in
            // Asnhjhjhjusigning values directly from the row
            let idValue=row[id]
            let medicationValue = row[medication]
            let timingsValue = row[timings]
            let takenStatus = row[taken]
            let frequencyValue = row[frequency]
            let timesValue = row[times]
            let quantityValue = row[quantity]
            let refillStatus = row[refill]
            let deletedStatus = row[deleted]
            let lastUpdatedValue = row[lastUpdated]
            let createdValue = row[created]
            let rem1Value = row[rem1]
            let rem2Value = row[rem2]
            let rem3Value = row[rem3]
            let rem4Value = row[rem4]
            let wday1Value = row[wday1]
            let wday2Value = row[wday2]
            let wday3Value = row[wday3]
            let wday4Value = row[wday4]
            let wday5Value = row[wday5]
            let wday6Value = row[wday6]
            let wday7Value = row[wday7]
            
            
            
            
           // let rem5Value = row[rem5]
            //let rem6Value = row[rem6]

            // Constructing a Schedule object
            return Schedule(
                id:idValue,
                medication: medicationValue,
                timings: timingsValue,
                taken: takenStatus,
                frequency: frequencyValue,
                times: timesValue,
                quantity: quantityValue,
                refill: refillStatus,
                deleted: deletedStatus,
                lastUpdated: lastUpdatedValue,
                created: createdValue,
                rem1: rem1Value,
                rem2: rem2Value,
                rem3: rem3Value,
                rem4: rem4Value,
                
                wday1: wday1Value,
                wday2: wday2Value,
                wday3: wday3Value,
                wday4: wday4Value,
                wday5: wday5Value,
                wday6: wday6Value,
                wday7: wday7Value
                
                
                //rem5: rem5Value,
                //rem6: rem6Value
            )
        }
    }
    
    
    
    //func updateReminderTimeForMedication_month(medicationName: String, newMonthDays: String, newReminderTime: Date) throws {
        func updateReminderTimeForMedication_month(medicationName: String,newReminderTime: Date) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicationToUpdate = schedule.filter(medication == medicationName)

        // Format newReminderTime to a String
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "hh:mm a"
        let newReminderTimeString = dateFormatter.string(from: newReminderTime)

        // First, clear existing reminder times
        let clearRemindersStatement = medicationToUpdate.update(
            rem1 <- "",  // Or use an appropriate default value
            rem2 <- "",
            rem3 <- "",
            rem4 <- ""
        )
        try db.run(clearRemindersStatement)

        // Then, update with new values
        let updateStatement = medicationToUpdate.update(
          //  month_days <- newMonthDays,
            rem1 <- newReminderTimeString
            // Update other reminder columns if needed
        )

        try db.run(updateStatement)
    }

    
    //func to update weekly reminder time updates
        func updateReminderTimeForMedication_week(medicationName: String,newReminderTime: Date) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicationToUpdate = schedule.filter(medication == medicationName)

        // Format newReminderTime to a String
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "hh:mm a"
        let newReminderTimeString = dateFormatter.string(from: newReminderTime)

        // First, clear existing reminder times
        let clearRemindersStatement = medicationToUpdate.update(
            rem1 <- "",  // Or use an appropriate default value
            rem2 <- "",
            rem3 <- "",
            rem4 <- ""
        )
        try db.run(clearRemindersStatement)

        // Then, update with new values
        let updateStatement = medicationToUpdate.update(
          //  month_days <- newMonthDays,
            rem1 <- newReminderTimeString
            // Update other reminder columns if needed
        )

        try db.run(updateStatement)
    }

    
    
    
    
    
    
    
    
    func updateTakenToggle(reminderID: Int64, newStatus: Bool) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let reminderToUpdate = remindersHome.filter(r_I_ID == reminderID)
        try db.run(reminderToUpdate.update(r_B_takentoggle <- newStatus))
    }

    
    
    
    
    
    
    
    
    
    
    // Public method to clear reminder times
    func clearReminderTimes(medicationName: String) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicationToUpdate = schedule.filter(medication == medicationName)
        let clearStatement = medicationToUpdate.update(
            rem1 <- "",
            rem2 <- "",
            rem3 <- "",
            rem4 <- ""
        )
        try db.run(clearStatement)
    }

    
    
    func updateDayForMedication(medication: String, dayColumn: String, dayValue: String) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicationToUpdate = schedule.filter(self.medication == medication)
        // print("DB Update - Medication: \(medication), Column: \(dayColumn), Value: \(dayValue)")
        try db.run(medicationToUpdate.update(Expression<String>(dayColumn) <- dayValue))
    }

    
    
    
    
    
    
    
    
   


    func markMedicineRowAsDeleted(_ medicine: MedicineRow) throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let medicineToUpdate = schedule.filter(id == medicine.id)
        try db.run(medicineToUpdate.update(
            deleted <- true,
            lastUpdated <- ISO8601DateFormatter().string(from: Date()) // Update lastUpdated date
        ))
    }

    
    func getNextDate(countDateWeekday: Int, countDate: Date, newWeekday: Int) -> Date {
        let calendar = Calendar.current

        // Ensure the weekdays are within the valid range
        guard countDateWeekday >= 0 && countDateWeekday <= 6 &&
              newWeekday >= 0 && newWeekday <= 6 else {
            return countDate
        }

        var daysToAdd: Int

        if countDateWeekday < newWeekday {
            // Calculate the number of days to add
            daysToAdd = newWeekday - countDateWeekday
        } else if countDateWeekday > newWeekday {
            // Calculate the days to add when wrapping around the week
            daysToAdd = 7 - countDateWeekday + newWeekday
        } else {
            // No days to add if the weekdays are the same
            return countDate
        }

        // Add the calculated days to countDate
        if let newDate = calendar.date(byAdding: .day, value: daysToAdd, to: countDate) {
            return newDate
        }

        return countDate // Return the original date if calculation fails
    }

    
    func getLocalTimeZoneDifferenceFromUTC() -> Int {
        let currentTimeZone = TimeZone.current
        let timeZoneOffset = currentTimeZone.secondsFromGMT() // Offset in seconds

        // Convert the offset to hours
        let timeZoneDifferenceInHours = timeZoneOffset / 3600
        return timeZoneDifferenceInHours
    }
    //KIDO 2_3:1C  Begin edit doesn't capture dosage iter adjustment seen after 5 PM etc
  
   
    //Kido end 2_3:1c
    
    
    func isAftertime(createdDateString: String, timeDifference: Int) -> Bool {
        let dateFormatterWithSeconds = DateFormatter()
        dateFormatterWithSeconds.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZ"
        
        let dateFormatterWithoutSeconds = DateFormatter()
        dateFormatterWithoutSeconds.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        
        let fallbackDateFormatter = DateFormatter()
        fallbackDateFormatter.dateFormat = "yyyy-MM-dd"
        let fallbackDate = fallbackDateFormatter.date(from: "1900-01-01")!
        
        // First, try to create the date including seconds
        var createdDate = dateFormatterWithSeconds.date(from: createdDateString)
        
        // If parsing fails, try without seconds
        if createdDate == nil {
            createdDate = dateFormatterWithoutSeconds.date(from: createdDateString)
        }
        
        // Use the fallback date if both attempts fail
        let finalCreatedDate = createdDate ?? fallbackDate
        // print("IS AFTER----------------")
        print(finalCreatedDate)
        
        // Get the start of the next day
        var nextDay = Calendar.current.startOfDay(for: finalCreatedDate)
        nextDay.addTimeInterval(24 * 60 * 60) // Add 24 hours (1 day)
        
        // Calculate the difference in hours
        let components = Calendar.current.dateComponents([.hour], from: finalCreatedDate, to: nextDay)
        if let hoursTillEndOfDay = components.hour {
            // print("hoursTillEndOfDay", hoursTillEndOfDay)
            // print("timeDifference", timeDifference)
            
            // If hours till end of day is greater than or equal to timeDifference, return false
            return hoursTillEndOfDay < timeDifference
        } else {
            // print("I am in else of isAfterTime")
            return false
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    func createAndInsertReminderHomeDuplicates(scheduleId: Int64, qty: Int) throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        // Fetch the Schedule row
        let query = schedule.filter(id == scheduleId)
        guard let scheduleRow = try db.pluck(query) else {
            throw NSError(domain: "DatabaseError", code: 101, userInfo: ["description": "Schedule not found"])
        }

        // Extract values from scheduleRow
        let master=scheduleRow[id]
        let medicine = scheduleRow[medication]
        let frequency = scheduleRow[frequency]
        let taken = scheduleRow[taken]
        let times = scheduleRow[times]
        let qty1 = scheduleRow[quantity]
        let qty = scheduleRow[quantity]
        let rem1 = scheduleRow[rem1]
        let rem2 = scheduleRow[rem2]
        let rem3 = scheduleRow[rem3]
        let rem4 = scheduleRow[rem4]
        let created = scheduleRow[created]
        let wday1 = scheduleRow[wday1]
        let wday2 = scheduleRow[wday2]
        let wday3 = scheduleRow[wday3]
        let wday4 = scheduleRow[wday4]
        let wday5 = scheduleRow[wday5]
        let wday6 = scheduleRow[wday6]
        let wday7 = scheduleRow[wday7]
        let month_days = scheduleRow[month_days] ?? ""
        let deleted = scheduleRow[deleted]
        let masterString = String(master)
        var Morning: String = "14:30"
       var eve5pm = "17:00:00"
        var noon12pm="12:00:00"
        var morn10am="10:00:00"
        
        var eve5pm1 = 7
        var noon12pm1 = 12
        var morn10am1 = 14
        
       var isCreatedAfter5PM = false
        var isCreatedAfter12PM = false
        var isCreatedAfter10AM = false
        // Extract other necessary fields...

        // Initialize the ReminderHome array
        var remindersArray: [[ReminderHome]] = []
        // DateFormatter for converting String to Date and vice versa
        let dateFormatter = ISO8601DateFormatter()
            dateFormatter.formatOptions = [.withFullDate, .withDashSeparatorInDate]

        // Initialize count and countDate
        var count = 0
        var countDate = dateFormatter.date(from: created) ?? Date()
        var countDate2 = dateFormatter.date(from: created) ?? Date()// wday code
        
       
            
        
        // Create a DateFormatter
        let dateFormatter2 = DateFormatter()
        dateFormatter2.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"

       
            
            // print("created test update^^^")
        print(created)
            let result1 = isAftertime(createdDateString: created, timeDifference: eve5pm1)
            let result2 = isAftertime(createdDateString: created, timeDifference: noon12pm1)
            let result3 = isAftertime(createdDateString: created, timeDifference: morn10am1)
            // print("@@result1",result1)
            // print("@@result2",result2)
            // print("@@result3",result3)
            
            
         
        
        
        
        
        
            
          
        
        
        
        
        
        
        var createdDate = dateFormatter.date(from: created) ?? Date()
    
        
        
        
        
        
        
        
        var totalDaysToAdd: Int = 0
        var endDate: Date?
       var timesC=0
 
        
       
        isCreatedAfter5PM = isAftertime(createdDateString: created, timeDifference: eve5pm1)
        isCreatedAfter12PM = isAftertime(createdDateString: created, timeDifference: noon12pm1)
        isCreatedAfter10AM = isAftertime(createdDateString: created, timeDifference: morn10am1)
        // print("isCreatedAfter5PM",isCreatedAfter5PM )
        // print("isCreatedAfter12PM",isCreatedAfter12PM)
        // print("isCreatedAfter10AM",isCreatedAfter10AM)
        
        
        
        
        
        var dayIncrement = 0
        var dayIncrement1 = 0

        for _ in 0..<qty1 {
            // Calculate 'totalDaysToAdd' based on 'frequency'
           
            totalDaysToAdd=0
            
            if frequency == "M" {
                totalDaysToAdd = (( qty * times-1)-1)
            } else if frequency == "W" {
                totalDaysToAdd = ((qty / times) * 7)//Enddateweek
            } else {
                totalDaysToAdd = qty / times
            }
            
            
            
            
            

            // Calculate 'endDate'
            let endDate = Calendar.current.date(byAdding: .day, value: totalDaysToAdd, to: createdDate) ?? Date()
            let endDateString = dateFormatter.string(from: endDate)
            
         

            // Increment 'count' and update 'countDate'
            
            
            
            
            
            count += 1
            // print("count",count)
            // Condition check
            
    
            
            
            if frequency == "D" && isCreatedAfter5PM && times > 1 {
          //  if frequency == "D" && isCreatedAfter5PM && times > 1 {
            count = times
            // print("countD5:")
            isCreatedAfter5PM = false
            isCreatedAfter12PM = false
            isCreatedAfter10AM = false
        }
            
            else
            
            if frequency == "D" && isCreatedAfter12PM && times > 2 {
               // if frequency == "D" && isCreatedAfter12PM && times > 2 {
                count = times-1
                // print("countD12:")
                isCreatedAfter12PM = false
                isCreatedAfter10AM = false
                isCreatedAfter5PM = false
            }
            else
            
            if frequency == "D" && isCreatedAfter10AM && times > 3 {
                      // if frequency == "D" && isCreatedAfter10AM && times > 3 {
                       count = times-2
                     // print("countD1:")
                       isCreatedAfter5PM = false
                       isCreatedAfter12PM = false
                       isCreatedAfter10AM = false
                   }
                   
                  
                  
                   
                  
                       
            
            
           
           
            
            
            
            if count > times {
                count = 1
                if frequency == "D" {
                    dayIncrement = 1
                } else if frequency == "W" {
                    dayIncrement = 7
                }  else {
                    dayIncrement = 0
                }
                countDate = Calendar.current.date(byAdding: .day, value: dayIncrement, to: countDate) ?? Date()
                countDate2=countDate
            }
            if (frequency == "M" ) {
                if(count > 1){
                    dayIncrement1 =  times}
                // print("dayIncrementM ", dayIncrement1)
                countDate = Calendar.current.date(byAdding: .day, value: dayIncrement1, to: countDate) ?? Date()
                countDate2=countDate
            }
        
            
        
        
            ///
            
            if frequency == "W" {
                let calendar = Calendar.current

                switch count {
                case 1:
                    countDate2 = countDate
                case 2:
                    if let countDateWeekday = Int(wday1), let newWeekday = Int(wday2) {
                        countDate2 = getNextDate(countDateWeekday: countDateWeekday, countDate: countDate, newWeekday: newWeekday)
                    }
                case 3:
                    if let countDateWeekday = Int(wday1), let newWeekday = Int(wday3) {
                        countDate2 = getNextDate(countDateWeekday: countDateWeekday, countDate: countDate, newWeekday: newWeekday)
                    }
                case 4:
                    if let countDateWeekday = Int(wday1), let newWeekday = Int(wday4) {
                        countDate2 = getNextDate(countDateWeekday: countDateWeekday, countDate: countDate, newWeekday: newWeekday)
                    }
                case 5:
                    if let countDateWeekday = Int(wday1), let newWeekday = Int(wday5) {
                        countDate2 = getNextDate(countDateWeekday: countDateWeekday, countDate: countDate, newWeekday: newWeekday)
                    }
                case 6:
                    if let countDateWeekday = Int(wday1), let newWeekday = Int(wday6) {
                        countDate2 = getNextDate(countDateWeekday: countDateWeekday, countDate: countDate, newWeekday: newWeekday)
                    }
                // ... Repeat for cases 5, 6 ...
                default:
                    break
                }
            }

            
            
            
            
            
            
            
           ///
            
            
            
            

            
            var reminder = ReminderHome(
                r_I_ID: 0, // Auto-generated
                r_S_medicine: medicine,
                r_B_takentoggle: taken,
                r_I_times: times,
                r_I_frequency: frequency,
                r_I_takendays:0,
                r_D_startdate: created,
                r_I_originalqty: qty1,
                r_I_updatedqty:qty1,
                r_T_rem1: rem1,
                r_T_rem2: rem2,
                r_T_rem3: rem3,
                r_T_rem4: rem4,
                r_S_wday1: wday1,
                r_S_wday2: wday2,
                r_S_wday3: wday3,
                r_S_wday4: wday4,
                r_S_wday5: wday5,
                r_S_wday6: wday6,
                r_S_wday7: wday7,
                r_S_monthdays: month_days,
                r_B_deleted: deleted,
                r_D_datetobetaken: dateFormatter.string(from: countDate2),
                r_B_master:master ,
                r_I_dosageIter: String(count),
                r_D_enddate: endDateString,
                r_D_created: created,
                r_D_updated:""

               // "0" for duplicates
            )

            // Set additional fields like r_D_enddate if necessary

            // Add to the reminders array
            remindersArray.append([reminder])
        }

        
        

        // Insert duplicates into ReminderHome
    
        for reminderList in remindersArray {
            for reminder in reminderList {
                
                
                let insert = remindersHome.insert(
                    r_S_medicine <- reminder.r_S_medicine,
                    r_B_takentoggle <- reminder.r_B_takentoggle,
                    r_I_frequency <- reminder.r_I_frequency,
                    r_I_times <- reminder.r_I_times,
                    r_I_takendays <- reminder.r_I_takendays,
                    r_D_startdate <- reminder.r_D_startdate,
                    r_I_originalqty <- reminder.r_I_originalqty,
                    r_I_updatedqty <- reminder.r_I_updatedqty,
                    r_T_rem1 <- reminder.r_T_rem1,
                    r_T_rem2 <- reminder.r_T_rem2,
                    r_T_rem3 <- reminder.r_T_rem3,
                    r_T_rem4 <- reminder.r_T_rem4,
                    r_S_wday1 <- reminder.r_S_wday1,
                    r_S_wday2 <- reminder.r_S_wday2,
                    r_S_wday3 <- reminder.r_S_wday3,
                    r_S_wday4 <- reminder.r_S_wday4,
                    r_S_wday5 <- reminder.r_S_wday5,
                    r_S_wday6 <- reminder.r_S_wday6,
                    r_S_wday7 <- reminder.r_S_wday7,
                    r_S_monthdays <- reminder.r_S_monthdays,
                    r_B_deleted <- reminder.r_B_deleted,
                    r_D_datetobetaken <- reminder.r_D_datetobetaken,
                    r_B_master <- reminder.r_B_master,
                    r_I_dosageIter <- reminder.r_I_dosageIter,
                    r_D_enddate <- reminder.r_D_enddate,
                    r_D_created <- reminder.r_D_created,
                    r_D_updated <- reminder.r_D_updated
                )
                try db.run(insert)
            }
        }
    }

    
    
    private func createScheduleUpdateTrigger_rem1() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let createTriggerSQL = """
        CREATE TRIGGER IF NOT EXISTS update_remindershome_rem1_after_schedule_update
        AFTER UPDATE OF rem1 ON Schedule
        FOR EACH ROW
        BEGIN
            UPDATE RemindersHome
            SET R_T_rem1 = NEW.rem1
            WHERE R_B_master = OLD.id;
        END;
        """

        try db.execute(createTriggerSQL)
    }

    
    private func createRemindersHomeUpdateTrigger() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let createTriggerSQL = """
        CREATE TRIGGER IF NOT EXISTS update_remindershome_on_touch
        AFTER UPDATE ON RemindersHome
        FOR EACH ROW
        BEGIN
            UPDATE RemindersHome
            SET R_D_updated = datetime('now') -- This sets the R_D_updated column to the current UTC date and time.
            WHERE r_I_ID = NEW.r_I_ID; -- Assumes r_I_ID is the primary key for RemindersHome.
        END;
        """

        try db.execute(createTriggerSQL)
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    private func createScheduleUpdateTrigger_rem2() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }

        let createTriggerSQL = """
        CREATE TRIGGER IF NOT EXISTS update_remindershome_rem2_after_schedule_update
        AFTER UPDATE OF rem2 ON Schedule
        FOR EACH ROW
        BEGIN
            UPDATE RemindersHome
            SET R_T_rem2 = NEW.rem2
           
            WHERE R_B_master = OLD.id;
        END;
        """

        try db.execute(createTriggerSQL)
    }

  
    
    
    private func createScheduleUpdateTrigger_rem3() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_rem3_after_schedule_update
            AFTER UPDATE OF rem3 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_T_rem3 = NEW.rem3
                     
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_rem4() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_rem4_after_schedule_update
            AFTER UPDATE OF rem4 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_T_rem4 = NEW.rem4
                        
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday1() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        let createTriggerForWeeklySchedule1 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekday_after_schedule_insert
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 1
        BEGIN
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created) -- %w returns the weekday as 0-6 (Sunday-Saturday)
            WHERE id = NEW.id;
        END;
        """
        
        
        
        let createTriggerForWeeklySchedule2 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekday_after_schedule_insert2
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 2
        BEGIN
            -- Calculate wday1 based on the created date
            -- Calculate wday2 as wday1 + 4, wrapping around if necessary
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 4) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        
        
        let createTriggerForWeeklySchedule3 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_insert_3
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 3
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        let createTriggerForWeeklySchedule4 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_insert_4
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 4
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        
        let createTriggerForWeeklySchedule5 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_insert_5
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 5
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7),
                wday5 = ((strftime('%w', NEW.created) + 3) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        let createTriggerForWeeklySchedule6 = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_insert_6
        AFTER INSERT ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 6
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7),
                wday5 = ((strftime('%w', NEW.created) + 3) % 7),
                wday6 = ((strftime('%w', NEW.created) + 1) % 7)
        
            WHERE id = NEW.id;
        END;
        
        """
        // UPDATE LIST
        
        let createTriggerForWeeklySchedule1_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekday_after_schedule_update
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 1
        BEGIN
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created) -- %w returns the weekday as 0-6 (Sunday-Saturday)
            WHERE id = NEW.id;
        END;
        """
        
        
        
        let createTriggerForWeeklySchedule2_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekday_after_schedule_update2
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 2
        BEGIN
            -- Calculate wday1 based on the created date
            -- Calculate wday2 as wday1 + 4, wrapping around if necessary
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 4) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        
        
        let createTriggerForWeeklySchedule3_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_update_3
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 3
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        let createTriggerForWeeklySchedule4_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_update_4
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 4
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        
        
        let createTriggerForWeeklySchedule5_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_update_5
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 5
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7),
                wday5 = ((strftime('%w', NEW.created) + 3) % 7)
            WHERE id = NEW.id;
        END;
        
        """
        let createTriggerForWeeklySchedule6_U = """
        CREATE TRIGGER IF NOT EXISTS insert_weekdays_after_schedule_update_6
        AFTER UPDATE ON Schedule
        WHEN NEW.frequency = 'W' AND NEW.times = 6
        BEGIN
            -- Update the Schedule row directly
            UPDATE Schedule
            SET wday1 = strftime('%w', NEW.created),
                wday2 = ((strftime('%w', NEW.created) + 2) % 7),
                wday3 = ((strftime('%w', NEW.created) + 4) % 7),
                wday4 = ((strftime('%w', NEW.created) + 6) % 7),
                wday5 = ((strftime('%w', NEW.created) + 3) % 7),
                wday6 = ((strftime('%w', NEW.created) + 1) % 7)
        
            WHERE id = NEW.id;
        END;
        
        """
        
        
        
        // UPDATE LIST END FOR SCHEDULE
        
        
        
        let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday1_after_schedule_update
            AFTER UPDATE OF wday1 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday1 = NEW.wday1
                WHERE R_B_master = OLD.id;
            END;
            """
        
        
        
        
        
        
        try db.execute(createTriggerForWeeklySchedule1)
        try db.execute(createTriggerForWeeklySchedule2)
        try db.execute(createTriggerForWeeklySchedule3)
        try db.execute(createTriggerForWeeklySchedule4)
        try db.execute(createTriggerForWeeklySchedule5)
        try db.execute(createTriggerForWeeklySchedule6)
        try db.execute(createTriggerForWeeklySchedule1_U)
        try db.execute(createTriggerForWeeklySchedule2_U)
        try db.execute(createTriggerForWeeklySchedule3_U)
        try db.execute(createTriggerForWeeklySchedule4_U)
        try db.execute(createTriggerForWeeklySchedule5_U)
        try db.execute(createTriggerForWeeklySchedule6_U)
        
        try db.execute(createTriggerSQL)
        
    }


    private func createScheduleUpdateTrigger_wday2() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday2_after_schedule_update
            AFTER UPDATE OF wday2 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday2 = NEW.wday2
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday3() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday3_after_schedule_update
            AFTER UPDATE OF wday3 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday3 = NEW.wday3
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday4() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday4_after_schedule_update
            AFTER UPDATE OF wday4 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday4 = NEW.wday4
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday5() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday5_after_schedule_update
            AFTER UPDATE OF wday5 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday5 = NEW.wday5
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday6() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday6_after_schedule_update
            AFTER UPDATE OF wday6 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday6 = NEW.wday6
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }


    private func createScheduleUpdateTrigger_wday7() throws {
            guard let db = self.db else {
                throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
            }

            let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindershome_wday7_after_schedule_update
            AFTER UPDATE OF wday7 ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_S_wday7 = NEW.wday7
                WHERE R_B_master = OLD.id;
            END;
            """

            try db.execute(createTriggerSQL)
        }




    
    
    
    
    
    
    
    
    
    
    
    
    
    
    private func createUpdateTrigger() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        
        /*let createTriggerSQL = """
        CREATE TRIGGER IF NOT EXISTS update_month_days_trigger
        AFTER UPDATE OF times ON Schedule
        BEGIN
           UPDATE Schedule SET month_days = (SELECT CASE
                                                    WHEN NEW.times IS NOT NULL THEN 'UpdatedValue'
                                                    ELSE month_days
                                                END)
            WHERE id = NEW.id;
        END;
        """*/
        
        
        let createTriggerSQL = """
        CREATE TRIGGER IF NOT EXISTS update_month_days_trigger
        AFTER UPDATE OF times ON Schedule
        BEGIN
           UPDATE Schedule SET month_days = NEW.times
            WHERE id = NEW.id;
        END;
        """
        
        
        

        try db.execute(createTriggerSQL)
    }

    
    private func createMedicineUpdateTrigger() throws {
        guard let db = self.db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        
    /*    let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindersHome_on_medicine_update
            AFTER UPDATE ON Schedule
            BEGIN
                UPDATE RemindersHome
                SET R_B_deleted = 1
                WHERE R_B_master = NEW.id;
            END;
        """
*/
        let createTriggerSQL = """
            CREATE TRIGGER IF NOT EXISTS update_remindersHome_on_medicine_update
            AFTER UPDATE OF medication,frequency, quantity, times, deleted ON Schedule
            FOR EACH ROW
            BEGIN
                UPDATE RemindersHome
                SET R_B_deleted = 1
                WHERE R_B_master = OLD.id;
            END;
        """



        try db.execute(createTriggerSQL)
    }

    
    
    
    func insertMedicineRow(_ medicine: MedicineRow) throws -> Int64 {
    
 //   func insertMedicineRow(_ medicine: MedicineRow) throws {
        guard let db = db else {
            throw NSError(domain: "DatabaseError", code: 100, userInfo: ["description": "Database connection not established"])
        }
        let dateFormatter = ISO8601DateFormatter()
        //
        //
        
        dateFormatter.timeZone = TimeZone.current // Set to the current timezone
        
               let createdDateString = dateFormatter.string(from: medicine.created)
                // print("$$$$$$$$createdDateString",createdDateString)
        let insertStatement = schedule.insert(
            medication <- medicine.medicine,
                        timings <- "", // Adjust based on your logic
                        taken <- false,
                        frequency <- medicine.frequency,
                        quantity <- medicine.quantity,
                        times <- medicine.times,
                        refill <- medicine.refill,
                        deleted <- false,
                        lastUpdated <- dateFormatter.string(from: Date()), // Current timestamp
                        created <- createdDateString // Insert the created date string
                        
                        
        )
        
      //  try db.run(insertStatement)
        let rowId = try db.run(insertStatement)
        // location where Reminder home gets updated for a new record added.
        try createAndInsertReminderHomeDuplicates(scheduleId: rowId, qty: medicine.quantity)
        return rowId
    }

    
    
    
    }//class






    // Define a struct for Schedule data
struct Schedule: Identifiable {
    var id: Int64
    var medication: String
    var timings: String
    var taken: Bool
    var frequency: String
    var times: Int
    var quantity: Int
    var refill: Bool
    var deleted: Bool
    var lastUpdated: String
    var created: String
    var rem1: String
    var rem2: String
    var rem3: String
    var rem4: String
    
    var wday1: String
    var wday2: String
    var wday3: String
    var wday4: String
    var wday5: String
    var wday6: String
    var wday7: String
    
    //var rem5: String
   // var rem6: String
}

    
    
    // Define a struct for Schedule data
   

struct ReminderHome {
    var r_I_ID: Int64
    var r_S_medicine: String
    var r_B_takentoggle: Bool
    var r_I_times: Int
    var r_I_frequency: String
    var r_I_takendays: Int
    var r_D_startdate: String
    var r_I_originalqty: Int
    var r_I_updatedqty: Int
    var r_T_rem1: String
    var r_T_rem2: String
    var r_T_rem3: String
    var r_T_rem4: String
    var r_S_wday1: String
    var r_S_wday2: String
    var r_S_wday3: String
    var r_S_wday4: String
    var r_S_wday5: String
    var r_S_wday6: String
    var r_S_wday7: String
    var r_S_monthdays: String
    var r_B_deleted: Bool
    var r_D_datetobetaken: String
    var r_B_master: Int64
    var r_I_dosageIter: String
    var r_D_enddate: String
    var r_D_created: String
    var r_D_updated: String
    // Additional properties if needed
}




extension DatabaseManager {
    
}
